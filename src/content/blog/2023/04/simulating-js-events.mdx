---
title: '"Simulating" JS Events'
description: "Let's have a look at React Aria. I've been wanting to do this for a while..."
pubDate: "2023-04-20"
tags: ["javascript", "frontend", "chrome extension", "events"]
socialImage: "simulating-js-events.jpg"
---

import SandpackEnv from "../../../../components/Sandpack";
import {
    keyboardEventsDispatchEvents,
    keyboardEventsInputDotValue,
    keyboardEventsInputOnly,
    mouseEventsButtonOnly,
    mouseEventsDotClick,
    mouseEventsEventsClick,
} from "./_simulating-js-events-code.js";

I've been working on my _[Google Workspace Zoom Default][webstore]_ Chrome Extension to implement a
[requested feature][feature-request] where users can use custom zoom values in addition to the predefined zoom values
that Google provides in their application's zoom dropdown.

I thought to myself, "I already simulate events. This should be easy." So, I started to try and figure it out. If you
want to skip ahead, feel free to go to the ["Implementing with `chrome.debugger`"](#implementing-with-chrome-debugger)
section.

But first, let's have a look at how to "simulate events."

## Mouse Events

Simulating mouse events is pretty simple. Or, is it?

Turns out there's many, many different ways to do it. Let's start by figuring out what events are
dispatched when a user clicks the button. Try it out in the example below.

<SandpackEnv files={mouseEventsButtonOnly.files} client:idle />

As you can see, there are three events that trigger when you click once (we'll only handle a single click).

These are (and executed in the following order):

-   `mousedown`
-   `mouseup`
-   `click`

Well well, there's three events that trigger. Fair enough.

What is interesting though is that `click` is at the end instead of the events instead of in the middle of the down and up
events. Something to think about ðŸ˜‰

Let's try to replicate this now using just JS.

### Using `.click()`

The first option you'd probably reach for (and myself), is using the `click()` method that exists on an `HTMLElement`.

Let's give it a shot and see how it works.

<SandpackEnv files={mouseEventsDotClick.files} client:visible />

After trying that, do you see the problem with trying to use `click()` to simulate clicks with JS?

In case you didn't, the problem is that when using the `click()` method, the only event that is triggered when simulating
the click is the "click" event. We are missing out on the "mousedown" and "mouseup" events.

This may be fine for some things, but may not work for everything.

### Dispatching Events

Let's make this a bit more bulletproof. Instead of using the `click()` method, we can actually go about dispatching events
on the element in question. To do this you use the [`EventTarget.dispatchEvent()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent)

Something like below would dispatch a click event on the button.

```javascript
const button = document.querySelector("button");
const event = new MouseEvent("click", {
    view: window,
    bubbles: true,
    cancelable: true,
    clientX: 0,
    clientY: 0,
    button: 0,
});
button.dispatchEvent(event);
```

Now, all we need to do is make into something that will execute all three events when a button is clicked. I've put it
in the example below. Give it a shot.

<SandpackEnv files={mouseEventsEventsClick.files} client:visible />

ðŸ¤¯ BOOMMMMMM... Now we have finally simulated a "click" using JS. Finally ðŸ”¥

### Gotchas (still...)

There's still some potential gotchas when it comes to simulating these events.

This is due to the pesky `isTrusted` property on the events. TL;DR - some browsers / apps will only respond to trusted
events. From [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted):

> The isTrusted read-only property of the `Event` interface is a boolean value that is true when the event was generated by a user action, and false when the event was created or modified by a script or dispatched via `EventTarget.dispatchEvent()`.

This property cannot be faked, so when something won't happen due to this, you're pretty much out of luck (aside from
what I'll show you [below](#implementing-with-chrome-debugger), which is a hack and **only** available to Chrome
Extensions).

While this doesn't up for the most part when simulating Mouse Events, it does come up when trying to simulate Keyboard
Events, which I'll demonstrate in the next section.

## Keyboard Events

Cool cool. Keyboard Events are going to be just as easy. You would've thought...

Let's see what triggers a Keyboard Event.

<SandpackEnv files={keyboardEventsInputOnly.files} client:visible />

Depending on what key you hit the following events will fire(in order):

1. `keydown`
2. `keypress`
3. `keyup`

or, if hitting a key like "Shift":

1. `keydown`
2. `keyup`

Now that we've gotten these events down, let's try to simulate them. Good thing that we have `KeyboardEvent`s that can
be dispatched just like `MouseEvent`s. Let's give it a shot.

<SandpackEnv files={keyboardEventsDispatchEvents.files} client:visible />

Notice anything _interesting_?? In case you were too fixated on the "Console" window, have a look at the input. Unfortunately,
while the vents did fire there is nothing in the input box.

Remember how I talked about the `isTrusted` property on the `Event` (see above)? Well, this is very much what is happening
here. The browser is being smart enough to not let scripts insert values in to input boxes. Basically, it's a security
concern and browsers are right in doing this.

So, where do we go from here? I still want to simulate these events. Maybe we can change the input's value using JS.
Let's give it a shot.

<SandpackEnv files={keyboardEventsInputDotValue.files} client:visible />

Perfect. It looks like my script is typing in the box. Before you celebrate, what is happening in the "Console" window?

Turns out, nothing is happening. There are no events being triggered despite us having listeners on them. So, we are not
"simulating" events.

Unfortunately, what we can do with `MouseEvent`s is not possible with `KeyboardEvents` due to browser security issues. We
can get pretty far in making it either:

1. Dispatch the correct events
2. **OR...** emulate typing

## Trusted Keyboard Events with Chrome Debugger

While it's not normally possible to fully simulate keyboard events, this section explores a potential "workaround" by using
the Chrome Debugger.

**ðŸš¨ This only works with Chrome Extensions that have access to the [`chrome.debugger` API](https://developer.chrome.com/docs/extensions/reference/debugger/) ðŸš¨**

Workaround here

[feature-request]: https://github.com/vernak2539/chrome-extension-google-doc-default-zoom/issues/15
[webstore]: https://chrome.google.com/webstore/detail/google-docs-zoom-default/nflkcdlimipkgbacnfnhfecjgmojhklo

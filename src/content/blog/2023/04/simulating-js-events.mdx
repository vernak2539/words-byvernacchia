---
title: '"Simulating" JS Events'
description: "Let's have a look at React Aria. I've been wanting to do this for a while..."
pubDate: "2023-04-20"
tags: ["javascript", "frontend", "chrome extension", "events"]
socialImage: "simulating-js-events.jpg"
---

import SandpackEnv from "../../../../components/Sandpack";
import {
    mouseEventsButtonOnly,
    mouseEventsDotClick,
    mouseEventsEventsClick,
} from "./_simulating-js-events-code.js";

I've been working on my _[Google Workspace Zoom Default][webstore]_ Chrome Extension to implement a
[requested feature][feature-request] where users can use custom zoom values in addition to the predefined zoom values
that Google provides in their application's zoom dropdown.

I thought to myself, "I already simulate events. This should be easy." So, I started to try and figure it out. If you
want to skip ahead, feel free to go to the ["Implementing with `chrome.debugger`"](#implementing-with-chrome-debugger)
section.

But first, let's have a look at how to "simulate events."

## Mouse Events

Simulating mouse events is pretty simple. Or, is it?

Turns out there's many, many different ways to do it. Let's start by figuring out what events are
dispatched when a user clicks the button. Try it out in the example below.

<SandpackEnv files={mouseEventsButtonOnly.files} client:idle />

As you can see, there are three events that trigger when you click once (we'll only handle a single click).

These are (and executed in the following order):

-   `mousedown`
-   `mouseup`
-   `click`

Well well, there's three events that trigger. Fair enough.

What is interesting though is that `click` is at the end instead of the events instead of in the middle of the down and up
events. Something to think about ðŸ˜‰

Let's try to replicate this now using just JS.

### Using `.click()`

The first option you'd probably reach for (and myself), is using the `click()` method that exists on an `HTMLElement`.

Let's give it a shot and see how it works.

<SandpackEnv files={mouseEventsDotClick.files} client:visible />

After trying that, do you see the problem with trying to use `click()` to simulate clicks with JS?

In case you didn't, the problem is that when using the `click()` method, the only event that is triggered when simulating
the click is the "click" event. We are missing out on the "mousedown" and "mouseup" events.

This may be fine for some things, but may not work for everything.

### Dispatching Events

Let's make this a bit more bulletproof. Instead of using the `click()` method, we can actually go about dispatching events
on the element in question. To do this you use the [`EventTarget.dispatchEvent()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent)

Something like below would dispatch a click event on the button.

```javascript
const button = document.querySelector("button");
const event = new MouseEvent("click", {
    view: window,
    bubbles: true,
    cancelable: true,
    clientX: 0,
    clientY: 0,
    button: 0,
});
button.dispatchEvent(event);
```

Now, all we need to do is make into something that will execute all three events when a button is clicked. I've put it
in the example below. Give it a shot.

<SandpackEnv files={mouseEventsEventsClick.files} client:visible />

ðŸ¤¯ BOOMMMMMM... Now we have finally simulated a "click" using JS. Finally ðŸ”¥

### Gotchas (still...)

There's still some potential gotchas when it comes to simulating these events.

This is due to the pesky `isTrusted` property on the events. TL;DR - some browsers / apps will only respond to trusted
events. From [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted):

> The isTrusted read-only property of the `Event` interface is a boolean value that is true when the event was generated by a user action, and false when the event was created or modified by a script or dispatched via `EventTarget.dispatchEvent()`.

This property cannot be faked, so when something won't happen due to this, you're pretty much out of luck (aside from
what I'll show you [below](#implementing-with-chrome-debugger), which is a hack and **only** available to Chrome
Extensions).

While this doesn't up for the most part when simulating Mouse Events, it does come up when trying to simulate Keyboard
Events, which I'll demonstrate in the next section.

## Keyboard Events

Here is where we have problems...

## Trusted Keyboard Events with Chrome Debugger

**ðŸš¨ This only works with Chrome Extensions that have access to the [`chrome.debugger` API](https://developer.chrome.com/docs/extensions/reference/debugger/) ðŸš¨**

[feature-request]: https://github.com/vernak2539/chrome-extension-google-doc-default-zoom/issues/15
[webstore]: https://chrome.google.com/webstore/detail/google-docs-zoom-default/nflkcdlimipkgbacnfnhfecjgmojhklo
